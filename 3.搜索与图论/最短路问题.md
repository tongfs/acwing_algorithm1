# 单源最短路

## 都是正权边（Dijkstra 算法）

### 朴素的 Dijkstra 算法

1. 初始化所有距离，`d[1] = 0`，`d[i] = +∞`
2. 循环 `n - 1` 次，每次找到未访问过的距离最近的点 `t`（ `O(n)` ），再由 `t` 去更新其他点的距离（ `O(n)` ）
3. 总的时间复杂度 `O(n^2)`

### 堆优化的 Dijkstra 算法

1. 每次取出一个距离最近的点 `t`，最多取 `n` 次
2. 遍历点 `t` 的所有的边，总共最多遍历 `m` 条边
3. 总的时间复杂度 `O(mlogn)`

## 存在负权边

### Bellman - Ford 算法

- 有边数限制的最短路只能用 BF 算法
- BF 只要求最短路径上没有负环即可，SPFA 一定要求图中不能有负环
- 要有 `backup[]` 数组进行备份，不然可能会发生串联
- 时间复杂度 `O(mn)`

### SPFA 算法

- 最短路问题基本都能用 SPFA
- 是 BF 的优化。BF 暴力枚举每一条边，SPFA 则维护了一个队列（栈、集合等都可以），只有距离变小了的节点才会进入队列，然后去更新其他节点
- 不需要 `backup[]` 数组，因为没有边数限制
- 代码很像堆优化版的 Dijkstra 算法，只不过 SPFA 有负权边
- 时间复杂度一般 `O(m)`，最坏 `O(mn)`



# 多源汇最短路

## Floyd 算法

- 基于动态规划
- `d[k, i, j]`：从 `i` 出发，只经过 `[1...k]` 这些中间点，到达 `j` 的最短距离

- 时间复杂度 `O(n^3)`
